<svg xmlns="http://www.w3.org/2000/svg" width="1920" height="1080" viewBox="0 0 1920 1080">
  <defs>
    <!-- Wireframe gradient matching website blue (#00A8FF) -->
    <linearGradient id="wireGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#00A8FF" />
      <stop offset="50%" stop-color="#00BFFF" />
      <stop offset="100%" stop-color="#008ED2" />
    </linearGradient>
    
    <!-- Glow filter matching website blue (#00A8FF) -->
    <filter id="glow" x="-30%" y="-30%" width="160%" height="160%">
      <feGaussianBlur stdDeviation="6" result="blur" />
      <feComponentTransfer in="blur" result="glow">
        <feFuncR type="linear" slope="0" intercept="0" />
        <feFuncG type="linear" slope="2.8" intercept="0" />
        <feFuncB type="linear" slope="5" intercept="0.3" />
      </feComponentTransfer>
      <feComposite operator="over" in="glow" in2="SourceGraphic" />
    </filter>
    
    <!-- Center line glow matching website blue (#00A8FF) -->
    <filter id="centerGlow" x="-40%" y="-40%" width="180%" height="180%">
      <feGaussianBlur stdDeviation="12" result="blur" />
      <feComponentTransfer in="blur" result="glow">
        <feFuncR type="linear" slope="0" intercept="0" />
        <feFuncG type="linear" slope="3.5" intercept="0" />
        <feFuncB type="linear" slope="5.5" intercept="0.3" />
      </feComponentTransfer>
      <feComposite operator="over" in="glow" in2="SourceGraphic" />
    </filter>
    
    <!-- Very subtle fog effect -->
    <radialGradient id="radialFog" cx="50%" cy="60%" r="80%" fx="50%" fy="60%">
      <stop offset="0%" stop-color="#000000" stop-opacity="0" />
      <stop offset="80%" stop-color="#000022" stop-opacity="0.2" />
      <stop offset="100%" stop-color="#000033" stop-opacity="0.4" />
    </radialGradient>
  </defs>
  
  <!-- Transparent background -->
  
  <!-- Wireframe Container - moved down in z direction (increased y value) -->
  <g id="wireframe-container" transform="translate(960, 700)">
    <!-- Wireframe will be dynamically generated by script -->
  </g>
  
  <!-- Very subtle fog overlay -->
  <rect width="100%" height="100%" fill="url(#radialFog)" opacity="0.3" />
  
  <!-- Animation script -->
  <script type="text/javascript"><![CDATA[
    window.onload = function() {
      // Configuration
      const config = {
        // Grid properties
        xSize: 101,         // Points for higher detail
        ySize: 35,          // Depth layers
        xSpacing: 45,       // Spacing
        ySpacing: 65,       // Depth spacing
        
        // Perspective properties
        ySkew: 0.3,         // Moderate skew for perspective
        
        // Animation properties
        animationSpeed: 0.015, // Slower animation
        
        // Visual properties
        lineWidth: 1.8,
        highlightEvery: 8,  // Adjusted for larger grid
        
        // Function scale - moderate amplitude with offset
        zScale: 110,         // Base amplitude scale
        zOffset: -80,       // Push animation down in Z direction
        
        // Distance fade properties
        maxVisibleDepth: 0.65,  // Extended visibility depth
        fadeStartDepth: 0.15,   // Start fading earlier for more gradual effect
        
        // Opacity and glow settings
        minOpacity: 0.4,       // Minimum opacity for closest lines
        maxOpacity: 1.0,       // Maximum opacity for closest lines
        glowIntensity: 2.0     // Maximum glow effect
      };
      
      // Get DOM elements
      const wireframeContainer = document.getElementById('wireframe-container');
      
      // Scene state
      let scene = {
        time: 0,
        params: {
          // Base wave parameters with interesting amplitude combinations
          a1: 0.8,    // Higher amplitude for primary wave
          f1: 0.2,    // Frequency
          p1: 0.0,    // Phase
          s1: 0.8,    // Speed
          
          a2: 0.4,    // Medium amplitude
          f2: 0.18,   // Frequency
          p2: 0.5,    // Phase
          s2: 0.6,    // Speed
          
          a3: 0.2,    // Lower amplitude
          f3: 0.15,   // Frequency
          p3: 1.0,    // Phase
          s3: 0.5,    // Speed
          
          a4: 0.35,   // Medium-low amplitude
          f4: 0.12,   // Frequency
          p4: 1.5,    // Phase
          s4: 0.55,   // Speed
          
          // Additional mixed waves with varied amplitudes
          a5: 0.15,   // Lower amplitude
          f5: 0.3,    // Higher frequency
          p5: 0.8,    // Phase
          s5: 0.9,    // Speed
          
          a6: 0.5,    // Higher amplitude for this slower wave
          f6: 0.06,   // Lower frequency - longer wave
          p6: 1.7,    // Phase
          s6: 0.25,   // Slower speed
          
          a7: 0.08,   // Very low amplitude for micro detail
          f7: 0.5,    // Very high frequency
          p7: 0.3,    // Phase
          s7: 1.1,    // Speed
          
          a8: 0.3,    // Medium amplitude
          f8: 0.13,   // Frequency
          p8: 2.1,    // Phase
          s8: 0.4,    // Speed
          
          // New additional waves for more interesting interference patterns
          a9: 0.25,   // Medium-low amplitude
          f9: 0.09,   // Lower frequency
          p9: 0.7,    // Phase
          s9: 0.3,    // Speed
          
          a10: 0.18,  // Low amplitude
          f10: 0.22,  // Higher frequency
          p10: 1.2,   // Phase
          s10: 0.75,  // Speed
        }
      };
      
      // Create grid of points
      function createGrid() {
        const grid = [];
        // Calculate the position to ensure grid fills screen width
        const xHalfSize = (config.xSize * config.xSpacing) / 2;
        
        for (let y = 0; y < config.ySize; y++) {
          const row = [];
          // Y increases into the screen (depth)
          const yPos = y * config.ySpacing;
          
          for (let x = 0; x < config.xSize; x++) {
            // X goes from left to right
            const xPos = x * config.xSpacing - xHalfSize;
            
            row.push({
              x: xPos,                 // Screen horizontal position
              y: yPos,                 // Depth into screen
              z: 0,                    // Height (will be calculated)
              screenX: xPos,           // Projected X (horizontal)
              screenY: 0,              // Projected Y (vertical - Z in our 3D space)
              isHighlight: x % config.highlightEvery === 0 || y % config.highlightEvery === 0,
              isCenter: x === Math.floor(config.xSize / 2) || y === Math.floor(config.ySize / 2)
            });
          }
          grid.push(row);
        }
        
        return grid;
      }
      
      // The grid of points in 3D space
      const grid = createGrid();
      
      // Project a 3D point (x, y, z) to 2D screen coordinates
      function projectPoint(point) {
        // Apply perspective to Y (depth)
        // As Y increases (goes deeper into screen), points get closer together horizontally
        const perspectiveFactor = 1 - (point.y * 0.0006); // Adjusted for much larger grid
        
        // X is straight across screen, but affected by perspective
        const screenX = point.x * perspectiveFactor;
        
        // Z is vertical on screen (negative because SVG Y is inverted)
        // Also apply perspective to Z - things further away appear smaller
        const screenY = -point.z * perspectiveFactor;
        
        // Apply Y skew - things further away appear higher on screen
        const ySkewFactor = point.y * config.ySkew;
        
        return {
          x: screenX,
          y: screenY - ySkewFactor  // Apply the Y skew
        };
      }
      
      // Enhanced Z function with more interesting amplitude combinations
      function calculateZ(x, y, time, params) {
        // Convert coordinates to normalized space for wave calculations
        const nx = x * 0.005;  // Adjusted for larger grid
        const ny = y * 0.005;  // Adjusted for larger grid
        const dist = Math.sqrt(nx*nx + ny*ny); // Distance from center
        
        // Geographic location functions for location-dependent patterns
        const xCenter = Math.abs(nx); // Distance from vertical centerline
        const yCenter = Math.abs(ny); // Distance from horizontal centerline
        const corner = Math.max(xCenter, yCenter); // Distance from nearest corner
        
        // Wave 1: Basic sine wave along X axis
        const wave1 = params.a1 * Math.sin(nx * params.f1 + time * params.s1);
        
        // Wave 2: Cosine wave along Y axis
        const wave2 = params.a2 * Math.cos(ny * params.f2 + time * params.s2);
        
        // Wave 3: Radial wave from center
        const wave3 = params.a3 * Math.sin(dist * params.f3 + time * params.s3);
        
        // Wave 4: Product wave - mixed sin/cos
        const wave4 = params.a4 * Math.sin(nx * params.f4) * Math.cos(ny * params.f4 + time * params.s4);
        
        // Wave 5: Ultra high frequency detail wave
        const wave5 = params.a5 * Math.sin(nx * params.f5 * 2 + time * params.s5) * 
                     Math.cos(ny * params.f5 + time * (params.s5 * 0.7));
        
        // Wave 6: Longer period wave for slow undulation - HIGHER AMPLITUDE
        const wave6 = params.a6 * Math.sin(dist * params.f6 - time * params.s6);
        
        // Wave 7: Very high frequency micro-detail
        const wave7 = params.a7 * Math.sin(nx * params.f7 * nx + time * params.s7) * 
                     Math.cos(ny * params.f7 * ny + time * params.s7 * 0.8);
        
        // Wave 8: Mixed frequency wave with xy interaction
        const wave8 = params.a8 * Math.sin((nx + ny) * params.f8 + time * params.s8) * 
                     Math.cos((nx - ny) * params.f8 * 0.7 + time * params.s8 * 1.2);
        
        // Wave 9: Location-dependent amplitude wave - stronger at edges
        const edgeFactor = xCenter + 0.2;  // Gets stronger toward edges
        const wave9 = params.a9 * edgeFactor * Math.sin(ny * params.f9 + time * params.s9);
        
        // Wave 10: Location-dependent frequency - higher frequency at center
        const centerFrequency = params.f10 * (1.5 - dist); // Higher frequency at center
        const wave10 = params.a10 * Math.cos(nx * centerFrequency + time * params.s10);
        
        // Add non-uniform amplitude distribution - create interesting bumps and valleys
        const terrainFactor = 0.2 * Math.sin(nx * 0.2) * Math.cos(ny * 0.3) + 
                             0.15 * Math.cos(dist * 2) + 
                             0.25 * Math.sin(corner * 0.1);
        
        // Combine all waves with location-based amplitude variations
        return (wave1 + wave2 + wave3 + wave4 + wave5 + wave6 + wave7 + wave8 + wave9 + wave10 + terrainFactor) * 
              config.zScale + config.zOffset;
      }
      
      // Enhanced depth visibility calculation
      function calculateDepthVisibility(depth) {
        // Get normalized depth (0-1)
        const normalizedDepth = depth / (config.ySize - 1);
        
        // If beyond max visible depth, hide completely
        if (normalizedDepth > config.maxVisibleDepth) {
          return 0;
        }
        
        // If before fade start, show fully
        if (normalizedDepth < config.fadeStartDepth) {
          return 1;
        }
        
        // Otherwise, calculate non-linear fade (cubic curve for more natural fog effect)
        const fadeProgress = (normalizedDepth - config.fadeStartDepth) / 
                            (config.maxVisibleDepth - config.fadeStartDepth);
        
        // Use cubic ease-out curve for more natural fog appearance
        return 1 - (fadeProgress * fadeProgress * fadeProgress);
      }
      
      // Update parameters for animation with more interesting timing patterns
      function updateParams(time) {
        const params = scene.params;
        
        // Create interesting beating patterns with non-harmonic oscillations
        params.a1 = 0.8 + 0.25 * Math.sin(time * 0.2);
        params.a2 = 0.4 + 0.18 * Math.cos(time * 0.17);
        params.a3 = 0.2 + 0.1 * Math.sin(time * 0.13);
        params.a4 = 0.35 + 0.15 * Math.cos(time * 0.16);
        // Higher amplitude variation for the long wave - creates interesting plateaus
        params.a6 = 0.5 + 0.3 * Math.sin(time * 0.08);
        // Other amplitudes with subtle variations
        params.a5 = 0.15 + 0.07 * Math.sin(time * 0.12);
        params.a7 = 0.08 + 0.04 * Math.cos(time * 0.22);
        params.a8 = 0.3 + 0.12 * Math.sin(time * 0.19);
        params.a9 = 0.25 + 0.1 * Math.cos(time * 0.14);
        params.a10 = 0.18 + 0.08 * Math.sin(time * 0.21);
        
        // Create slight frequency modulation
        params.f1 = 0.2 + 0.02 * Math.sin(time * 0.11);
        params.f2 = 0.18 + 0.015 * Math.cos(time * 0.09);
        params.f3 = 0.15 + 0.01 * Math.sin(time * 0.08);
        params.f4 = 0.12 + 0.012 * Math.cos(time * 0.07);
        params.f5 = 0.3 + 0.03 * Math.sin(time * 0.06);
        params.f6 = 0.06 + 0.008 * Math.cos(time * 0.05);
        params.f7 = 0.5 + 0.06 * Math.sin(time * 0.04);
        params.f8 = 0.13 + 0.015 * Math.cos(time * 0.05);
        params.f9 = 0.09 + 0.01 * Math.sin(time * 0.07);
        params.f10 = 0.22 + 0.02 * Math.cos(time * 0.08);
        
        // Varied phase change speeds for more complex wave interaction
        params.p1 += 0.008;
        params.p2 += 0.007;
        params.p3 += 0.005;
        params.p4 += 0.009;
        params.p5 += 0.012;
        params.p6 += 0.003; // Slow phase change for long wavelength
        params.p7 += 0.015;
        params.p8 += 0.006;
        params.p9 += 0.004;
        params.p10 += 0.01;
        
        return params;
      }
      
      // Create SVG elements for the wireframe
      
      // Lines along X axis (horizontal on screen)
      const xLines = [];
      for (let y = 0; y < config.ySize; y++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke', 'url(#wireGradient)');
        line.setAttribute('stroke-width', config.lineWidth);
        
        // Make the center line more prominent
        if (y === Math.floor(config.ySize / 2)) {
          line.setAttribute('stroke-width', config.lineWidth * 2.5);
          line.setAttribute('filter', 'url(#centerGlow)'); // Enhanced center glow
        }
        else if (y % config.highlightEvery === 0) {
          line.setAttribute('stroke-width', config.lineWidth * 1.8);
          line.setAttribute('filter', 'url(#glow)');
        }
        
        wireframeContainer.appendChild(line);
        xLines.push(line);
      }
      
      // Lines along Y axis (depth into screen)
      const yLines = [];
      for (let x = 0; x < config.xSize; x++) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke', 'url(#wireGradient)');
        line.setAttribute('stroke-width', config.lineWidth);
        
        // Make the center line more prominent
        if (x === Math.floor(config.xSize / 2)) {
          line.setAttribute('stroke-width', config.lineWidth * 2.5);
          line.setAttribute('filter', 'url(#centerGlow)'); // Enhanced center glow
        }
        else if (x % config.highlightEvery === 0) {
          line.setAttribute('stroke-width', config.lineWidth * 1.8);
          line.setAttribute('filter', 'url(#glow)');
        }
        
        wireframeContainer.appendChild(line);
        yLines.push(line);
      }
      
      // Animation loop
      function animate() {
        scene.time += config.animationSpeed;
        
        // Update parameters
        const params = updateParams(scene.time);
        
        // Calculate Z values (height) for all points in the grid
        for (let y = 0; y < config.ySize; y++) {
          // Add y-axis wave effect - cosine waves traveling along the y-axis
          const yWaveOffset = 
            20 * Math.cos(y * 0.15 + scene.time * 0.5) + 
            15 * Math.cos(y * 0.25 - scene.time * 0.3) +
            10 * Math.cos(y * 0.1 + scene.time * 0.2);
            
          for (let x = 0; x < config.xSize; x++) {
            const point = grid[y][x];
            point.z = calculateZ(point.x, point.y, scene.time, params) + yWaveOffset;
          }
        }
        
        // Add y-axis breathing effect - slight pulsing of depth
        const breathingScale = 1 + 0.05 * Math.sin(scene.time * 0.3);
        
        // Apply breathing effect to y values
        for (let y = 0; y < config.ySize; y++) {
          for (let x = 0; x < config.xSize; x++) {
            const point = grid[y][x];
            // Adjust y position based on breathing (creates subtle movement)
            point.y = y * config.ySpacing * breathingScale;
          }
        }
        
        // Project all points to screen coordinates
        for (let y = 0; y < config.ySize; y++) {
          for (let x = 0; x < config.xSize; x++) {
            const point = grid[y][x];
            const projected = projectPoint(point);
            point.screenX = projected.x;
            point.screenY = projected.y;
          }
        }
        
        // Sort rows by Y for proper depth rendering (back to front)
        const rowIndices = [];
        for (let y = 0; y < config.ySize; y++) {
          rowIndices.push(y);
        }
        
        // Sort rows by depth (y value) - back to front
        rowIndices.sort((a, b) => grid[b][0].y - grid[a][0].y);
        
        // Update lines along X axis (horizontal on screen)
        for (let i = 0; i < rowIndices.length; i++) {
          const y = rowIndices[i];
          
          // Calculate depth-based visibility with enhanced fog effect
          const depthVisibility = calculateDepthVisibility(y);
          
          // If completely invisible, skip rendering this line
          if (depthVisibility <= 0) {
            xLines[y].setAttribute('opacity', '0');
            continue;
          }
          
          const row = grid[y];
          const points = [];
          
          for (let x = 0; x < config.xSize; x++) {
            const point = row[x];
            points.push(`${point.screenX},${point.screenY}`);
          }
          
          xLines[y].setAttribute('points', points.join(' '));
          
          // Enhanced opacity calculation for more pronounced depth effect
          const depthRatio = y / config.ySize;
          const baseOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * depthRatio;
          
          // Apply depth visibility with fog effect
          const finalOpacity = baseOpacity * depthVisibility;
          
          // Make center and highlighted lines more vibrant
          if (y === Math.floor(config.ySize / 2)) {
            xLines[y].setAttribute('opacity', Math.min(1.0, finalOpacity * 1.4));
            
            // Pulse the center line intensity for dynamic effect - slower pulse
            const pulseIntensity = 0.8 + 0.4 * Math.sin(scene.time * 0.3);
            xLines[y].setAttribute('stroke-width', config.lineWidth * 2.5 * pulseIntensity);
          } 
          else if (y % config.highlightEvery === 0) {
            xLines[y].setAttribute('opacity', Math.min(1.0, finalOpacity * 1.2));
          }
          else {
            xLines[y].setAttribute('opacity', finalOpacity);
          }
        }
        
        // Update lines along Y axis (depth into screen)
        for (let x = 0; x < config.xSize; x++) {
          const points = [];
          let isVisible = false;
          let maxDepthVisibility = 0;
          
          for (let y = 0; y < config.ySize; y++) {
            // Only include visible points
            const depthVis = calculateDepthVisibility(y);
            if (depthVis > 0) {
              const point = grid[y][x];
              points.push(`${point.screenX},${point.screenY}`);
              isVisible = true;
              maxDepthVisibility = Math.max(maxDepthVisibility, depthVis);
            }
          }
          
          // If no visible points in this Y line, hide it
          if (!isVisible) {
            yLines[x].setAttribute('opacity', '0');
            continue;
          }
          
          yLines[x].setAttribute('points', points.join(' '));
          
          // Enhanced horizontal opacity distribution - center lines more pronounced
          const xCenter = config.xSize / 2;
          const distFromCenter = Math.abs(x - xCenter);
          const maxDist = xCenter;
          const xNorm = distFromCenter / maxDist; // 0 at center, 1 at edges
          
          // Use cubic curve for smoother falloff from center
          const horizontalFade = 1 - (xNorm * xNorm * 0.8);
          
          // Apply both horizontal distribution and depth visibility
          const baseOpacity = config.minOpacity + (config.maxOpacity - config.minOpacity) * horizontalFade;
          
          // Add sinusoidal wave pattern to y-axis line opacity for flowing effect
          const waveFactor = 0.25 * Math.sin(scene.time * 0.8 + x * 0.2) + 
                            0.15 * Math.cos(scene.time * 0.5 - x * 0.15);
          
          // Combine wave effect with basic opacity
          const finalOpacity = (baseOpacity + waveFactor) * maxDepthVisibility;
          
          // Make center and highlighted lines more vibrant
          if (x === Math.floor(config.xSize / 2)) {
            yLines[x].setAttribute('opacity', Math.min(1.0, finalOpacity * 1.4));
            
            // Enhanced pulse effect for center line - combined sine waves
            const pulseIntensity = 0.8 + 0.3 * Math.sin(scene.time * 0.3 + Math.PI/2) + 
                                 0.2 * Math.sin(scene.time * 0.7);
            yLines[x].setAttribute('stroke-width', config.lineWidth * 2.5 * pulseIntensity);
          }
          else if (x % config.highlightEvery === 0) {
            yLines[x].setAttribute('opacity', Math.min(1.0, finalOpacity * 1.2));
            
            // Add subtle width variation to highlighted lines
            const highlightPulse = 1 + 0.1 * Math.sin(scene.time * 0.2 + x * 0.1);
            yLines[x].setAttribute('stroke-width', config.lineWidth * 1.8 * highlightPulse);
          }
          else {
            yLines[x].setAttribute('opacity', finalOpacity);
          }
        }
        
        requestAnimationFrame(animate);
      }
      
      // Start animation
      animate();
    };
  ]]></script>
</svg>